This is the **Backend Project Roadmap** for The Foundry.

In Backend, "it works" is not enough. "It scales," "it is secure," and "it handles errors gracefully" are the metrics. We are moving away from visual feedback; your feedback is now logs, status codes, and database rows.

---

### **Tier 1: Rookie (The Scripting Savage)**
**Prerequisites:** Modules 0–3 (Terminal, Logic, File I/O, Basic SQL).
**The Hard Constraint:** **NO WEB FRAMEWORKS.** No Express, No Flask, No Spring Boot.
You are building Command Line Interfaces (CLIs) and Scripts. You need to learn how to manipulate data and the OS before you learn how to serve it.

#### **1. The "Big Data" Log Analyzer (Streams & I/O)**
*   **The Pitch:** Servers generate massive text logs. Your job is to make sense of them.
*   **The Twist:** I will provide you with a **2GB text file** (you can generate dummy data). You cannot load the whole file into memory (RAM) or your script will crash.
*   **The Challenge:**
    *   **Stream Processing:** Read the file line-by-line using Streams/Buffers.
    *   **Regex Extraction:** Extract IP addresses and timestamps from every line.
    *   **Logic:** Count unique IP addresses and find the top 5 "most active" IPs.
    *   **Output:** Write the results to a `report.json` file.
    *   **Tech:** File System (fs), Streams, Regex, HashMaps.

#### **2. The "Dirty" Data Migrator (ETL Pipeline)**
*   **The Pitch:** A client sent you a messy CSV of 10,000 users. You need to put it into a SQL Database.
*   **The Twist:** The data is garbage. Some emails are missing `@`, some ages are negative numbers.
*   **The Challenge:**
    *   **Sanitization:** Write a script that reads the CSV. If a row is invalid (bad email), write it to `bad_data.csv`. If it's valid, sanitize it (trim whitespace, lowercase emails).
    *   **Insertion:** Insert the clean data into a SQL Table (Postgres/MySQL) using raw SQL queries (no ORM).
    *   **Idempotency:** If I run the script twice, it should not create duplicate users.
    *   **Tech:** CSV Parsing, SQL `INSERT` / `ON CONFLICT`, Data Validation Logic.

#### **3. The "Bare Metal" HTTP Client**
*   **The Pitch:** Recreate "Postman" inside the Terminal.
*   **The Twist:** You cannot use a high-level library like `axios` or `requests`. You must use the language's native/standard low-level HTTP libraries.
*   **The Challenge:**
    *   **CLI Arguments:** The script runs like: `my-script GET https://jsonplaceholder.typicode.com/todos/1`.
    *   **Flag Handling:** Support flags like `-v` (verbose) to print the Headers and Status Code, and `-o filename` to save the response body to a file.
    *   **Error Handling:** Handle timeouts and DNS errors with human-readable messages.
    *   **Tech:** `sys.argv` (Python) or `process.argv` (Node), Native HTTP modules.

#### **4. The "Manual" Database (File System DB)**
*   **The Pitch:** Build a database engine using JSON files.
*   **The Twist:** Handle Race Conditions.
*   **The Challenge:**
    *   Create a script that supports `create`, `read`, `delete`.
    *   **Data Structure:** `db.json` holds the data.
    *   **Concurrency:** If two terminal windows try to write to the DB at the exact same time, the file will get corrupted. You must implement a **Lock File** mechanism (create `db.lock` before writing, delete it after).
    *   **Tech:** File Locking logic, JSON Serialization, Exception Handling.

#### **5. The "Portfolio" Scraper (Web Scraping)**
*   **The Pitch:** Build a bot that tracks prices or data from a website.
*   **The Twist:** You must be a "polite" bot.
*   **The Challenge:**
    *   Scrape a site (e.g., HackerNews or an E-commerce demo site).
    *   **Politeness:** Respect `robots.txt` (check if you are allowed to scrape). Implement a generic "delay" so you don't hit the server more than once per second.
    *   **Parsing:** Traverse the HTML DOM (using a parser like Cheerio or BeautifulSoup) to find specific data.
    *   **Tech:** DOM Traversal, HTTP Requests, Time Delays.

---

### **Tier 2: Adventurer (The API Architect)**
**Prerequisites:** Modules 4–7 (Web Server, ORMs, REST Architecture, Auth).
**The Hard Constraint:** **Production Standards.** Your API must return standard Status Codes (201, 400, 401, 403, 404, 500). No logging errors to the console; log them to a file.

#### **6. The "Expense Tracker" API (The REST Standard)**
*   **The Pitch:** A backend for managing personal finances.
*   **The Twist:** Complex filtering and aggregation.
*   **The Challenge:**
    *   **CRUD:** Create, Read, Update, Delete expenses.
    *   **Advanced Filtering:** `GET /expenses?category=food&min_amount=50&date_after=2023-01-01`.
    *   **Aggregation:** An endpoint `GET /expenses/summary` that uses SQL `SUM` and `GROUP BY` to return total spending per category (don't calculate this in a loop in code; let the DB do it).
    *   **Tech:** REST, SQL Aggregations, Query Parameter parsing.

#### **7. The "Secure" URL Shortener (Auth & Security)**
*   **The Pitch:** Bit.ly clone, but private.
*   **The Twist:** Security is the priority.
*   **The Challenge:**
    *   **Auth:** Users must Register and Login (JWT implementation). Only logged-in users can shorten URLs.
    *   **Rate Limiting:** A user can only create 10 URLs per hour. (Implement a basic Token Bucket in memory or Redis).
    *   **Nano-ID:** Generate unique short codes. Handle collisions (what if the code already exists?).
    *   **Redirect:** `GET /:code` redirects to the original URL and increments a "click count" in the DB.
    *   **Tech:** JWT, Hashing (Bcrypt), Middleware (Rate Limiting).

#### **8. The "Blog" with Roles (RBAC - Role Based Access Control)**
*   **The Pitch:** A CMS backend.
*   **The Twist:** Not all users are equal.
*   **The Challenge:**
    *   **Roles:** Admin, Editor, Viewer.
    *   **Permissions:**
        *   *Viewer:* Can only Read public posts.
        *   *Editor:* Can Create/Edit their *own* posts.
        *   *Admin:* Can Delete *anyone's* posts and Ban users.
    *   **Middleware:** Write a custom middleware `checkRole(['admin', 'editor'])` to protect routes.
    *   **Tech:** Middleware logic, DB Relationships (User hasOne Role).

#### **9. The "Flight Booking" System (Transactions)**
*   **The Pitch:** Reserve a seat on a plane.
*   **The Twist:** **Data Integrity.** What happens if the server crashes halfway through booking?
*   **The Challenge:**
    *   **The Problem:** Booking involves 3 steps: 1. Charge Payment. 2. Create Ticket. 3. Decrement "Available Seats" count.
    *   **The Solution:** Use **SQL Transactions** (ACID). If Step 3 fails, Step 1 and 2 must automatically roll back.
    *   **Concurrency:** Prevent "Double Booking" (two users booking the last seat at the same millisecond) using Row Locking.
    *   **Tech:** SQL Transactions (`BEGIN`, `COMMIT`, `ROLLBACK`), Pessimistic Locking.

#### **10. The "Physical" Library (Complex Data Modeling)**
*   **The Pitch:** Manage checking out physical books.
*   **The Twist:** Handling time and dates is a nightmare.
*   **The Challenge:**
    *   **The Model:** `Books`, `Members`, `Loans`.
    *   **Business Logic:** A user checks out a book. It is due in 14 days.
    *   **The Fine:** Create an endpoint that calculates the fine. $0.50 per day late.
    *   **Constraint:** Weekends don't count towards fines. You need to write logic to calculate "Business Days" between two dates.
    *   **Tech:** Date/Time Libraries (Luxon/Moment), Cron Jobs (to check for overdue books daily).

#### **11. The "Notification" Service (Background Jobs)**
*   **The Pitch:** An API that sends emails.
*   **The Twist:** You cannot send the email during the HTTP request (it's too slow).
*   **The Challenge:**
    *   **Queue:** When the user hits `POST /send-email`, you verify the data, add a "Job" to a Queue (Redis/BullMQ), and immediately return `202 Accepted`.
    *   **Worker:** A separate process runs in the background, picks up the job, and actually sends the email (simulated).
    *   **Retry Logic:** If the email fails, the worker must retry it 3 times with exponential backoff (1s, 2s, 4s) before marking it as "Failed".
    *   **Tech:** Message Queues, Async Processing, Separating Producer vs. Consumer.

---

### **Success Criteria (How to Pass Backend Code Review)**

1.  **Environment Variables:** If I see a database password or API key hardcoded in your file, instant fail. Use `.env`.
2.  **SQL Injection Proof:** If you concatenate strings for SQL queries (`"SELECT * FROM users WHERE name = " + userInput`), instant fail. Use Parameterized Queries.
3.  **Status Codes:** Do not return `200 OK` when the password was wrong. Return `401 Unauthorized`.
4.  **Error Handling:** The server must never crash. If I send a JSON with a missing bracket, the server should catch the error and return a `400`, not shut down.
5.  **Project Structure:** Controllers, Services, and Routes must be in separate files. No 500-line `index.js`.